/* Main.c file generated by New Project wizard
 *
 * Created:   Ср дек 23 2015
 * Processor: PIC18F4520
 * Compiler:  MPLAB XC8
 */
 
#include <xc.h>
#include <stdio.h>
#include <stdlib.h>

#pragma config OSC = HS, WDT = OFF
#pragma interrupt IRT

#define FREQ 8000000

#define Button_1 RA0
#define Button_2 RA1
#define TRIS_B_1 TRISA0
#define TRIS_B_2 TRISA1
#define spbrg_value (((FREQ/64)/9600)-1)

#define _XTAL_FREQ 8000000

//-------------------------------------------------------------------------//

/* Биты конфигурации ************/

    __CONFIG(1, HS);
    __CONFIG(2, BORDIS & PWRTEN & WDTDIS);
    __CONFIG(4, LVPDIS);


/********************************/
#include    "stdio.h"
#include    "string.h"
#include    "lcd.h"
//-------------------------------------------------------------------------//

// Global constants
unsigned char MODE = 0;					// 0 - SMS mode, 1 - GPRS mode
unsigned char GPRS_STATE = 0;				// 0 - GPRS is not initialized, 1 - ok
unsigned char DATA_READY = 0;				// 0 - RX is not ready, 1 - EOF msg, 2 - EOF buffer

// Global constants for user
unsigned char cmd_sms_address = "AT+CMGS=\"+79778218904\"";
unsigned char sms_text = "Test message from SIM900";
unsigned char cmd_url_address = "AT^SISS=0,address,http://www.yandex.ru";

unsigned char data[50];
unsigned char m = 0;


char lcd_buff[16];


void Delay_ms(unsigned int delay){
    int i, j;
    for(i = 0; i < delay; i++){
        for(j = 0; j < 310; j++) { ;}			// Do nothing
    }
}

int i = 0, j, k;

// Output your message in LCD
void output_lcd(char* message_1, char* message_2) {
   
   if (message_1) {   
      lcd_clear();
      Delay_ms(2); 
      lcd_gotoxy(0,0);
      sprintf(lcd_buff, message_1);
      lcd_puts(lcd_buff);
   }
   
   if (message_2) {
      lcd_gotoxy(1,0);
      sprintf(lcd_buff, "                                ");
      lcd_puts(lcd_buff);   
      Delay_ms(2);  
      lcd_gotoxy(1,0);
      sprintf(lcd_buff, message_2);
      lcd_puts(lcd_buff);      
   }
}

// Change Mode with outputing it to LCD
void change_mode() {
   
   if (MODE) MODE = 0;
   else MODE = 1;
      
   output_lcd(0, "reloading");   
   Delay_ms(300);
   output_lcd(0, "reloading.");   
   Delay_ms(300);
   output_lcd(0, "reloading..");   
   Delay_ms(300);
   output_lcd(0, "reloading...");   
   Delay_ms(300);
   
   if (MODE) {
      output_lcd("Mode: GPRS", 0);
   }
   else {
      output_lcd("Mode: SMS", 0);
   }
}

void tx_data(unsigned char serial_data) // Transmit data function
{
   TXREG = serial_data;
   while(PIR1bits.TXIF == 0); 		// Do nothing while not sended
}

void gsm_cmd(unsigned char *string) {
   i = 0; j = 0;
   while(string[i] != '\0')
   {
      if(string[i] == 0x5C) // Not to send '\' character
	 i++;
      tx_data(string[i]); // Send by serial communication
      i++;
   }
   tx_data(0x0D);
}


void send_sms() {
   gsm_cmd("AT+CMGF=1");
   Delay_ms(1000);

   gsm_cmd(cmd_sms_address);
   Delay_ms(1000);

   gsm_cmd(sms_text);
   tx_data(0x1A);
   Delay_ms(1000);
   
   /*
   
   Шаблон для обработки данных
   
   while (!DATA_READY) ;
      
   unsigned char* temp = &data[0];
   output_lcd(temp, 0);
   
   DATA_READY = 0;
   */
}

void init_gprs() {
   output_lcd("Loading SCFG", 0);
   Delay_ms(200);
   output_lcd("Loading SCFG.", 0);
   Delay_ms(200);
   output_lcd("Loading SCFG..", 0);
   Delay_ms(200);
   output_lcd("Loading SCFG...", 0);
   Delay_ms(200);
      
   
   gsm_cmd("AT^SCFG=Tcp/WithURCs,off");
   output_lcd(0, "1/6 init config");
   Delay_ms(1000);
   
   gsm_cmd("AT^SICS=0,conType,GPRS0");
   output_lcd(0, "2/6 init conType");
   Delay_ms(1000);
   
   gsm_cmd("AT^SICS=0,apn,internet.mts.ru");
   output_lcd(0, "3/6 init apn");
   Delay_ms(1000);
   
   gsm_cmd("AT^SICS=0,user,mts");
   output_lcd(0, "4/6 init user");
   Delay_ms(1000);
   
   gsm_cmd("AT^SICS=0,passwd,mts");
   output_lcd(0, "5/6 init passwd");
   Delay_ms(1000);
   
   gsm_cmd("AT^SICS=0,dns1,8.8.8.8");
   output_lcd(0, "6/6 added dns");   
   Delay_ms(1000);
   
   output_lcd("SCFG loaded", 0);
   Delay_ms(1000);
   
    
   output_lcd("Loading SISS", 0);
   Delay_ms(200);
   output_lcd("Loading SISS.", 0);
   Delay_ms(200);
   output_lcd("Loading SISS..", 0);
   Delay_ms(200);
   output_lcd("Loading SISS...", 0);
   Delay_ms(200);
   
   
   gsm_cmd("AT^SISS=0,srvType,Http");
   output_lcd(0, "1/4 init srvType");
   Delay_ms(1000);
   
   gsm_cmd("AT^SISS=0,conId,0");
   output_lcd(0, "2/4 init conId");
   Delay_ms(1000);
   
   gsm_cmd("AT^SISS=0,hcMethod,0");
   output_lcd(0, "3/4 init hcMetod");
   Delay_ms(1000);
   
   gsm_cmd(cmd_url_address);
   output_lcd(0, "4/4 init address");
   Delay_ms(1000);
   
   output_lcd("SISS loaded", 0);
   Delay_ms(1000);
   
   output_lcd("GPRS initialized", 0);
   Delay_ms(1000);
}


void send_request() {
   
   if (!GPRS_STATE) {
      init_gprs();
      GPRS_STATE = 1;
   }
   
   gsm_cmd("AT^SIS0=0");
   output_lcd("Connection", "Created");
   Delay_ms(1000);
   
   output_lcd("Requesting", 0);
   Delay_ms(1000);
   
   gsm_cmd("AT^SISR=0,1500");
   output_lcd(0, "1: ERROR");
   Delay_ms(1000);
   
   gsm_cmd("AT^SISR=0,1500");
   output_lcd(0, "2: OK");
   Delay_ms(1000);
   
   gsm_cmd("AT^SISR=0,1500");
   output_lcd(0, "3: EOF Document");
   Delay_ms(1000); 
   
   
}



//-------------------------------------------------------------------------//
void main (void){

lcd_init();
   
output_lcd("Mode: SMS", 0);
   
TRISCbits.RC0 = 1;
TRISCbits.RC1 = 1;
   
PORTCbits.RC0 = 0;
PORTCbits.RC1 = 0;
   
SPBRG = spbrg_value; // Fill SPBRG register to set the baud rate
RCSTAbits.SPEN = 1; // To activate serial port (Tx and Rx pins)
TXSTAbits.TXEN = 1; // Activate Transmissiom
RCSTAbits.CREN = 1; // Activate Reception
PIE1bits.RCIE = 1; // Enable Reception interrupt
INTCONbits.GIE = 1; // Enable Global interrupt
INTCONbits.PEIE = 1; // Enable Peripheral interrupt

/***********************************************/


while(1){	// Основной цикл
   
   if (PORTCbits.RC0 == 0) {
      if (MODE) {
	 send_request();
      }
      else {
	 send_sms();
      }
   }
   
   if (PORTCbits.RC1 == 0) {
      change_mode();
   }
}
}
//-------------------------------------------------------------------------//


void interrupt IRT(void)
{
   if (m < 50) {
      data[m] = RCREG;
      if(data[m++] == 0x0D) 	// check for return key
      {
	  DATA_READY = 1;	// Buffer is full and ready	
      }
   }
   else {
      m = 0; 
      DATA_READY = 2;		// EOF buffer
   }
}
